## Part 1. Настройка gitlab-runner

**== Задание ==**

##### Поднять виртуальную машину *Ubuntu Server 20.04 LTS*

##### Скачать и установить на виртуальную машину **gitlab-runner**

##### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)

**== Решение ==**

1) Устанавливаем gitlab-runner:

    - `curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash`

    - `apt-cache madison gitlab-runner`

    - `sudo apt-get install gitlab-runner`

2) Устанавливаем все необходимые пакеты в Ubuntu:

    - `sudo apt install make`

    - `sudo apt install gcc`

    - `sudo apt install clang-format`

3) Регистрируем проект:

    - `sudo gitlab-runner register`, указываем URL, токен и тэг

![gitlab-runner register](images/1.png)
 
## Part 2. Сборка

**== Задание ==**

#### Написать этап для **CI** по сборке приложений из проекта *C2_SimpleBashUtils*:

##### В файле _gitlab-ci.yml_ добавить этап запуска сборки через мейк файл из проекта _C2_

##### Файлы, полученные после сборки (артефакты), сохранять в произвольную директорию со сроком хранения 30 дней.

**== Решение ==**

1) Этап по сборке приложений представлен в .gitlab-ci.yml `stage: build`:

![.gitlab-ci.yml file content](images/2.png)

2) Запускаем на Ubuntu gitlab-runner командой ` sudo gitlab-runner run`:

![gitlab-runner run](images/3.png)

## Part 3. Тест кодстайла

**== Задание ==**

#### Написать этап для **CI**, который запускает скрипт кодстайла (*clang-format*):

##### Если кодстайл не прошел, то "зафейлить" пайплайн

##### В пайплайне отобразить вывод утилиты *clang-format*

**== Решение ==**

1) Напишем скрипт `style_test.sh`, который будет проверять кодстайл. В случае, если будет нарушение кодстайла, выводится текст с ошибкой и скрипт завершается с кодом 1. В этом случае пайплайн будет зафейлен:
![alt text](images/4.png)

2) Дополним файл `.gitlab-ci.yml` новым этапом `check-style`:

![alt text](images/5.png)

## Part 4. Интеграционные тесты

**== Задание ==**

#### Написать этап для **CI**, который запускает ваши интеграционные тесты из того же проекта:

##### Запускать этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно

##### Если тесты не прошли, то "зафейлить" пайплайн

##### В пайплайне отобразить вывод, что интеграционные тесты успешно прошли / провалились

**== Решение ==**

1) Напишем скрипты `src/integration_tests/cat_test.sh` и `src/integration_tests/grep_test.sh` для проверки проекта и создадим текстовый шаблон для `src/integration_tests/test.txt`.

2) Скрипт `src/integration_test.sh` запускает написанные нами скрипты и в случае ошибки возвращает код 1.

![alt text](images/6.png)

3) Дополним файл `.gitlab-ci.yml` новым этапом `integration-test`:

![alt text](images/7.png)

![alt text](images/8.png)

## Part 5. Этап деплоя

**== Задание ==**

##### Поднять вторую виртуальную машину *Ubuntu Server 20.04 LTS*

#### Написать этап для **CD**, который "разворачивает" проект на другой виртуальной машине:

##### Запускать этот этап вручную при условии, что все предыдущие этапы прошли успешно

##### Написать bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины

##### В файле _gitlab-ci.yml_ добавить этап запуска написанного скрипта

##### В случае ошибки "зафейлить" пайплайн

1) Подготовка к выполнению задания:

    - После создания второй машины устанавливаем для дирректории **/usr/local/bin** права командой: `sudo chmod -R 777 /usr/local/bin` .

    - На машине с **gitlab-runner** переключаемся на пользователя gitlab-runner `sudo su gitlab-runner`, создаем ssh-ключ `ssh-keygen` и устанавливаем беспарольное SSH копированием открытого ключа с помощью команды `ssh-copy-id linux2@192.168.64.5` .

    - Устанавливаем статическое соединение между машинами. Используем команды `sudo ip route add 192.168.64.0/24 via 192.168.64.5` и `sudo ip route add 192.168.64.0/24 via 192.168.64.4`

2) Создаем скрипт с копированием файлов через `scp`:

![alt text](images/9.png)

3) Добавляем новый этап в *.gitlab-ci.yml*:

![alt text](images/10.png)

4) Итог:
![alt text](images/11.png)

## Part 6. Дополнительно. Уведомления

**== Задание ==**

##### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем "[ваш nickname] DO6 CI/CD" в *Telegram*

- Текст уведомления должен содержать информацию об успешности прохождения как этапа **CI**, так и этапа **CD**.
- В остальном текст уведомления может быть произвольным.

**== Решение ==**

1) Создаем бота в Телеграм:

![alt text](images/12.png)

2) Создаем скрипт *notify.sh*, со следующим содержание:

![alt text](images/13.png)

3) Добавляем в *.gitlab-ci.yml* новый этап и дополняем этап деплоя. Финальный файл выглядит следующим образом:

![alt text](images/14.png)

![alt text](images/15.png)
![alt text](images/16.png)